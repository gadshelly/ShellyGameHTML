<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Room Editor</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body{font-family:Segoe UI,Arial,sans-serif;background:#f7f9fb;margin:0;padding:18px}
    .panel{max-width:1100px;margin:18px auto;background:#fff;padding:18px;border-radius:10px;box-shadow:0 6px 24px rgba(0,0,0,.06)}
    h1{margin:0 0 14px 0;color:#1e88e5}
    .row{display:flex;gap:12px;align-items:center}
    .controls{display:flex;gap:8px;margin-bottom:12px}
    button{background:#2196f3;color:#fff;border:none;padding:10px 14px;border-radius:8px;cursor:pointer}
    button.secondary{background:#eee;color:#222}
    .editor{display:grid;grid-template-columns:1fr 320px;gap:18px}
    .grid-wrap{background:#fafafa;padding:12px;border-radius:8px;min-height:360px}
    /* grid container is relative to allow multi-tile objects as absolute overlays */
    #roomGrid{display:grid;gap:6px;background:#fff;padding:8px;border-radius:6px;border:1px solid #eee;position:relative;overflow:auto}
    .tile{width:64px;height:64px;background:#f2f2f6;border-radius:6px;border:1px solid #ddd;display:flex;align-items:center;justify-content:center;position:relative;overflow:visible}
    .tile.disabled{opacity:.4;background:#444}
    .tile img{max-width:60px;max-height:60px;pointer-events:none}
    .placed-object{position:absolute;z-index:40;pointer-events:auto;display:flex;align-items:center;justify-content:center}
    .placed-object img{width:100%;height:100%;object-fit:contain;pointer-events:none;border-radius:4px}
    .placed-object .grid-inner{width:100%;height:100%;display:grid;grid-gap:0}
    .sidebar{background:#fff;padding:12px;border-radius:8px;border:1px solid #eee;height:100%;display:flex;flex-direction:column}
    .assets{flex:1;overflow:auto;padding:6px;border-radius:6px;background:#fcfcff}
    .asset-item{display:inline-block;width:64px;height:64px;margin:6px;border:1px solid #eee;border-radius:6px;background:#fafafa;vertical-align:top;cursor:grab;overflow:hidden;display:flex;align-items:center;justify-content:center}
    .asset-item img{max-width:60px;max-height:60px;display:block;margin:auto}
    .asset-mini-grid{width:100%;height:100%;display:grid;grid-gap:0}
    .asset-mini-grid img{width:100%;height:100%;object-fit:cover}
    .tabs{display:flex;gap:6px;margin-top:8px}
    .tab{padding:8px 10px;border-radius:6px;background:#f1f1f1;cursor:pointer}
    .tab.active{background:#2196f3;color:#fff}
    .mode-switch{margin-top:8px}
    .meta{margin-top:8px;font-size:13px;color:#666}
    .small{font-size:13px;color:#666}
    .footer-controls{display:flex;gap:8px;align-items:center;margin-top:10px}
    input[type=file]{display:none}
    .drop-target{outline:2px dashed transparent}
    .drop-target.over{outline:2px dashed #4caf50}
    @media(max-width:900px){.editor{grid-template-columns:1fr}}  
  </style>
</head>
<body>
  <div class="panel">
    <h1>Room Editor</h1>

    <div id="entryButtons" class="controls">
      <button id="newRoomBtn">Create New Room</button>
      <button id="loadRoomBtn" class="secondary">Load Room</button>
      <input id="loadRoomFile" type="file" accept="application/json">
      <div class="small">When creating a room you can switch between Place Objects and Create Background. Background tiles are behind objects.</div>
    </div>

    <div id="editorArea" style="display:none" class="editor">
      <div class="grid-wrap">
        <div class="row" style="justify-content:space-between;margin-bottom:8px">
          <div class="row">
            <label class="small">Name: <input id="roomName" type="text" style="margin-left:8px;padding:6px;border-radius:6px;border:1px solid #ddd"></label>
            <label class="small" style="margin-left:12px">Width: <input id="roomW" type="number" min="1" value="10" style="width:64px;margin-left:6px;padding:6px;border-radius:6px;border:1px solid #ddd"></label>
            <label class="small" style="margin-left:8px">Height: <input id="roomH" type="number" min="1" value="8" style="width:64px;margin-left:6px;padding:6px;border-radius:6px;border:1px solid #ddd"></label>
            <button id="resizeBtn" class="secondary" style="margin-left:8px">Resize Grid</button>
          </div>
          <div class="row">
            <button id="saveRoomBtn">Save Room</button>
            <button id="exportBtn" class="secondary">Export JSON</button>
          </div>
        </div>

        <div id="roomGrid" aria-label="Room grid"></div>
        <div class="meta small">Tip: Drag items from the assets panel at right and drop onto grid cells. Use the mode tabs to switch layers.</div>
      </div>

      <aside class="sidebar">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:6px">
          <div class="tabs">
            <div id="tabObjects" class="tab active">Place Objects</div>
            <div id="tabTiles" class="tab">Create Background</div>
          </div>
          <div class="mode-switch small">Layer: <strong id="activeLayer">Objects</strong></div>
        </div>

        <div class="assets" id="assetsPanel">
          <!-- asset thumbnails will go here -->
        </div>

        <div style="margin-top:8px">
          <label class="small">If assets do not load automatically, you can load them manually:</label>
          <div style="display:flex;gap:8px;margin-top:6px">
            <!-- allow images and .json files for objects -->
            <label style="background:#4caf50;color:#fff;padding:8px;border-radius:6px;cursor:pointer">Load Objects<input id="objFiles" type="file" accept="image/*,.json" multiple></label>
            <label style="background:#ff9800;color:#fff;padding:8px;border-radius:6px;cursor:pointer">Load Tiles<input id="tileFiles" type="file" accept="image/*" multiple></label>
          </div>
        </div>

        <div class="footer-controls">
          <button id="clearBtn" class="secondary">Clear Background</button>
          <button id="clearObjectsBtn" class="secondary">Clear Objects</button>
        </div>

        <div class="small meta" style="margin-top:8px">Loaded objects/tiles are stored in-memory for this session only. Saving a room embeds the images as data URLs in the JSON.</div>
      </aside>
    </div>
  </div>

<script>
// --- Model ---
let room = {
  name: '',
  width: 10,
  height: 8,
  background: [], // 2D array of tile srcs or null
  objects: [] // list of {id,x,y,w,h,grid,preview,src,name}
};

let assets = { objects: [], tiles: [] };
// assets.objects entries:
// - string (image src for 1x1 object)
// - { type:'object', data: <parsed JSON>, preview: <dataURL> }
let activeMode = 'objects'; // 'objects' or 'tiles'

const CELL_PX = 70; // pixel size used for positioning overlays

// --- UI references ---
const entryButtons = document.getElementById('entryButtons');
const newRoomBtn = document.getElementById('newRoomBtn');
const loadRoomBtn = document.getElementById('loadRoomBtn');
const loadRoomFile = document.getElementById('loadRoomFile');
const editorArea = document.getElementById('editorArea');
const roomGrid = document.getElementById('roomGrid');
const roomName = document.getElementById('roomName');
const roomW = document.getElementById('roomW');
const roomH = document.getElementById('roomH');
const resizeBtn = document.getElementById('resizeBtn');
const assetsPanel = document.getElementById('assetsPanel');
const tabObjects = document.getElementById('tabObjects');
const tabTiles = document.getElementById('tabTiles');
const activeLayer = document.getElementById('activeLayer');
const objFiles = document.getElementById('objFiles');
const tileFiles = document.getElementById('tileFiles');
const saveRoomBtn = document.getElementById('saveRoomBtn');
const exportBtn = document.getElementById('exportBtn');
const clearBtn = document.getElementById('clearBtn');
const clearObjectsBtn = document.getElementById('clearObjectsBtn');

// --- Utilities ---
function uid(){ return Math.random().toString(36).slice(2,9); }

function createEmptyGrid(w,h){
  const g = [];
  for(let y=0;y<h;y++){ g[y]=[]; for(let x=0;x<w;x++) g[y][x]=null; }
  return g;
}
function safeParseJSON(txt){ try { return JSON.parse(txt); } catch(e){ return null; }
}

function showEditor(){ entryButtons.style.display='none'; editorArea.style.display='grid'; }

// check if area (x..x+w-1, y..y+h-1) is free of existing objects
function isAreaFree(x,y,w,h){
  for(const o of room.objects){
    const ox1 = o.x, oy1 = o.y, ox2 = o.x + (o.w||1) - 1, oy2 = o.y + (o.h||1) - 1;
    const nx1 = x, ny1 = y, nx2 = x + w - 1, ny2 = y + h - 1;
    const overlap = !(ox2 < nx1 || ox1 > nx2 || oy2 < ny1 || oy1 > ny2);
    if(overlap) return false;
  }
  return true;
}

// --- Entry buttons ---
newRoomBtn.addEventListener('click',()=>{
  room.name=''; room.width=10; room.height=8; room.background=createEmptyGrid(10,8); room.objects=[];
  roomName.value=''; roomW.value=10; roomH.value=8; renderGrid(); showEditor();
});

loadRoomBtn.addEventListener('click',()=> loadRoomFile.click());
loadRoomFile.addEventListener('change',async e=>{
  const f = e.target.files[0];
  if(!f) return;
  const txt = await f.text();
  const data = safeParseJSON(txt);
  if(!data){ alert('Invalid JSON file'); return; }
  loadRoomFromData(data);
  showEditor();
});

function loadRoomFromData(data){
  room.name = data.name || '';
  room.width = data.width || 10;
  room.height = data.height || 8;
  room.background = (Array.isArray(data.background) && data.background.length) ? data.background : createEmptyGrid(room.width, room.height);
  room.objects = Array.isArray(data.objects) ? data.objects : [];
  roomName.value = room.name; roomW.value = room.width; roomH.value = room.height;
  renderGrid();
}

// --- Resize ---
resizeBtn.addEventListener('click',()=>{
  const w = parseInt(roomW.value,10) || 1;
  const h = parseInt(roomH.value,10) || 1;
  const newBg = createEmptyGrid(w,h);
  for(let y=0;y<Math.min(h, room.background.length); y++){
    for(let x=0;x<Math.min(w, (room.background[0] ? room.background[0].length : 0)); x++){
      newBg[y][x] = room.background[y] && room.background[y][x] ? room.background[y][x] : null;
    }
  }
  room.background = newBg;
  room.objects = room.objects.filter(o => (o.x + (o.w||1) <= w) && (o.y + (o.h||1) <= h));
  room.width = w; room.height = h;
  renderGrid();
});

// --- Asset manifest attempt ---
async function tryLoadManifest(){
  try{ const r1 = await fetch('/assets/objects/manifest.json'); if(r1.ok){ const list = await r1.json(); assets.objects = list.map(p=>'/assets/objects/'+p); } } catch(e){}
  try{ const r2 = await fetch('/assets/tiles/manifest.json'); if(r2.ok){ const list = await r2.json(); assets.tiles = list.map(p=>'/assets/tiles/'+p); } } catch(e){}
  populateAssets();
}

// create preview for object JSON (compose grid into one preview if possible)
async function makePreviewFromObjectJson(objJson){
  if(objJson.image) return objJson.image;
  const grid = objJson.grid;
  if(!Array.isArray(grid) || grid.length===0) return null;
  const tilePx = 32;
  const w = grid[0].length, h = grid.length;
  const canvas = document.createElement('canvas'); canvas.width = w*tilePx; canvas.height = h*tilePx;
  const ctx = canvas.getContext('2d');
  const loadImg = src => new Promise(res=>{
    const i = new Image(); i.crossOrigin='anonymous'; i.onload=()=>res(i); i.onerror=()=>res(null); i.src=src;
  });
  for(let yy=0; yy<h; yy++){
    for(let xx=0; xx<w; xx++){
      const s = grid[yy][xx];
      if(!s) continue;
      try{ const im = await loadImg(s); if(im) ctx.drawImage(im, xx*tilePx, yy*tilePx, tilePx, tilePx); }catch(e){}
    }
  }
  return canvas.toDataURL('image/png');
}

// create a mini DOM grid element to preview object's tiles in the palette
function createMiniGridElement(grid){
  const w = (Array.isArray(grid) && grid[0]) ? grid[0].length : 1;
  const h = Array.isArray(grid) ? grid.length : 1;
  const el = document.createElement('div');
  el.className = 'asset-mini-grid';
  el.style.gridTemplateColumns = `repeat(${w}, 1fr)`;
  for(let yy=0; yy<h; yy++){
    for(let xx=0; xx<w; xx++){
      const cell = document.createElement('div');
      const src = grid[yy] && grid[yy][xx] ? grid[yy][xx] : null;
      if(src){ const img = document.createElement('img'); img.src = src; cell.appendChild(img); }
      el.appendChild(cell);
    }
  }
  return el;
}

// --- Populate assets panel ---
async function populateAssets(){
  assetsPanel.innerHTML = '';
  const list = (activeMode === 'objects') ? assets.objects : assets.tiles;
  if(!list || list.length === 0){
    const note = document.createElement('div');
    note.className = 'small';
    note.textContent = 'No assets found. Use the Load buttons below to add images or .json object files from your machine.';
    assetsPanel.appendChild(note);
    return;
  }
  for(const item of list){
    const itemEl = document.createElement('div');
    itemEl.className = 'asset-item';
    itemEl.draggable = true;

    if(typeof item === 'string'){
      itemEl.title = item; itemEl.dataset.type = 'image'; itemEl.dataset.src = item;
      const img = document.createElement('img'); img.src = item; itemEl.appendChild(img);
    } else if(item && item.type === 'object'){
      itemEl.dataset.type = 'object'; itemEl.dataset.obj = JSON.stringify(item.data);
      itemEl.title = item.data && item.data.name ? item.data.name : 'Object';
      // prefer preview data URL if present
      if(item.preview){
        const img = document.createElement('img'); img.src = item.preview; itemEl.appendChild(img);
        itemEl.dataset.preview = item.preview;
      } else if(item.data && item.data.grid){
        // render small DOM grid preview so user sees tiles even without canvas preview
        const mini = createMiniGridElement(item.data.grid);
        itemEl.appendChild(mini);
      } else if(item.data && item.data.image){
        const img = document.createElement('img'); img.src = item.data.image; itemEl.appendChild(img);
      } else {
        const span = document.createElement('div'); span.className='small'; span.textContent = 'No preview'; itemEl.appendChild(span);
      }
    }

    itemEl.addEventListener('dragstart', ev=>{
      if(itemEl.dataset.type === 'image'){
        ev.dataTransfer.setData('text/plain', JSON.stringify({ assetType: 'image', src: itemEl.dataset.src }));
      } else {
        const objData = JSON.parse(itemEl.dataset.obj);
        ev.dataTransfer.setData('text/plain', JSON.stringify({ assetType: 'object', objectData: objData, preview: itemEl.dataset.preview || null }));
      }
      ev.dataTransfer.effectAllowed = 'copy';
    });

    assetsPanel.appendChild(itemEl);
  }
}

// --- File inputs (accept images and .json for objects) ---
objFiles.addEventListener('change', async e=>{
  for(const f of e.target.files){
    if(f.type === 'application/json' || f.name.endsWith('.json')){
      const txt = await f.text(); const parsed = safeParseJSON(txt); if(!parsed){ console.warn('Invalid object JSON skipped:', f.name); continue; }
      parsed.width = parsed.width || (Array.isArray(parsed.grid) && parsed.grid[0] ? parsed.grid[0].length : 1);
      parsed.height = parsed.height || (Array.isArray(parsed.grid) ? parsed.grid.length : 1);
      const preview = await makePreviewFromObjectJson(parsed).catch(()=>null);
      assets.objects.push({ type:'object', data: parsed, preview });
    } else if(f.type.startsWith('image/')){
      const dataUrl = await readFileAsDataURL(f); assets.objects.push(dataUrl);
    }
  }
  populateAssets();
});

tileFiles.addEventListener('change', async e=>{
  for(const f of e.target.files){ if(f.type.startsWith('image/')){ const dataUrl = await readFileAsDataURL(f); assets.tiles.push(dataUrl); } }
  populateAssets();
});

function readFileAsDataURL(f){ return new Promise(res=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(f); }); }

// --- Tabs ---
tabObjects.addEventListener('click', ()=>{ activeMode='objects'; tabObjects.classList.add('active'); tabTiles.classList.remove('active'); activeLayer.textContent='Objects'; populateAssets(); });
tabTiles.addEventListener('click', ()=>{ activeMode='tiles'; tabTiles.classList.add('active'); tabObjects.classList.remove('active'); activeLayer.textContent='Background'; populateAssets(); });

// --- Grid rendering ---
function renderGrid(){
  roomGrid.innerHTML = '';
  roomGrid.style.gridTemplateColumns = `repeat(${room.width}, 1fr)`;
  roomGrid.style.width = `${room.width * CELL_PX}px`;

  for(let y=0;y<room.height;y++){
    for(let x=0;x<room.width;x++){
      const cell = document.createElement('div'); cell.className='tile drop-target'; cell.dataset.x=x; cell.dataset.y=y;
      const bg = (room.background[y] && room.background[y][x]) ? room.background[y][x] : null;
      if(bg){ const bimg=document.createElement('img'); bimg.src=bg; bimg.style.opacity='0.95'; cell.appendChild(bimg); }

      cell.addEventListener('dragover', e=>{ e.preventDefault(); cell.classList.add('over'); e.dataTransfer.dropEffect='copy'; });
      cell.addEventListener('dragleave', ()=>cell.classList.remove('over'));
      cell.addEventListener('drop', e=>{
        e.preventDefault(); cell.classList.remove('over'); const txt=e.dataTransfer.getData('text/plain'); if(!txt) return; try{
          const payload = JSON.parse(txt);
          if(payload.assetType==='image'){
            if(activeMode==='tiles') placeAssetAt(payload.src, parseInt(x,10), parseInt(y,10), 'tiles'); else placeAssetAt(payload.src, parseInt(x,10), parseInt(y,10), 'objects');
          } else if(payload.assetType==='object'){
            placeParsedObjectAt(payload.objectData, parseInt(x,10), parseInt(y,10));
          }
        }catch(err){ console.error(err); }
      });

      roomGrid.appendChild(cell);
    }
  }

  // render placed objects as overlays
  for(const obj of room.objects){
    const w = obj.w||1, h = obj.h||1;
    const left = obj.x * CELL_PX, top = obj.y * CELL_PX;
    const overlay = document.createElement('div'); overlay.className='placed-object'; overlay.style.left=`${left}px`; overlay.style.top=`${top}px`;
    overlay.style.width = `${w*CELL_PX - 6}px`; overlay.style.height = `${h*CELL_PX - 6}px`;
    overlay.style.pointerEvents='auto'; overlay.dataset.objectId = obj.id; overlay.title = obj.name || 'object';

    if(obj.grid && Array.isArray(obj.grid)){
      const inner = document.createElement('div'); inner.className='grid-inner'; inner.style.gridTemplateColumns = `repeat(${w}, 1fr)`;
      for(let yy=0; yy<h; yy++){
        for(let xx=0; xx<w; xx++){
          const cellDiv = document.createElement('div'); cellDiv.style.width='100%'; cellDiv.style.height='100%';
          const src = obj.grid[yy] && obj.grid[yy][xx] ? obj.grid[yy][xx] : null; if(src){ const ti=document.createElement('img'); ti.src=src; ti.style.width='100%'; ti.style.height='100%'; ti.style.objectFit='cover'; cellDiv.appendChild(ti); }
          inner.appendChild(cellDiv);
        }
      }
      overlay.appendChild(inner);
    } else {
      const img = document.createElement('img'); img.src = obj.preview || obj.src || ''; overlay.appendChild(img);
    }

    overlay.addEventListener('contextmenu', e=>{ e.preventDefault(); const idx = room.objects.findIndex(o=>o.id===obj.id); if(idx>=0){ room.objects.splice(idx,1); renderGrid(); } });
    roomGrid.appendChild(overlay);
  }
}

// --- Place assets ---
function placeAssetAt(src,x,y,mode){
  if(mode==='tiles' || (mode===undefined && activeMode==='tiles')){
    if(!room.background || !Array.isArray(room.background)) room.background = createEmptyGrid(room.width, room.height);
    room.background[y][x] = src; renderGrid();
  } else {
    if(!isAreaFree(x,y,1,1)){ alert('Cannot place object: overlaps existing object'); return; }
    const obj = { id: uid(), x, y, w:1, h:1, src, preview: src, name: null };
    room.objects.push(obj); renderGrid();
  }
}

function placeParsedObjectAt(parsedObj,x,y){
  const w = parsedObj.width || (parsedObj.grid && parsedObj.grid[0] ? parsedObj.grid[0].length : 1);
  const h = parsedObj.height || (parsedObj.grid ? parsedObj.grid.length : 1);
  if(x + w > room.width || y + h > room.height){ alert('Object does not fit at that position. Resize room or place elsewhere.'); return; }
  if(!isAreaFree(x,y,w,h)){ alert('Cannot place object: it would overlap another object.'); return; }
  const objEntry = { id: uid(), x, y, w, h, grid: parsedObj.grid || null, src: parsedObj.image || null, name: parsedObj.name || null, preview: parsedObj._preview || null };
  room.objects.push(objEntry); renderGrid();
}

// --- Drag & drop into assets panel ---
assetsPanel.addEventListener('dragover', e=>{ e.preventDefault(); assetsPanel.style.background='#eef'; });
assetsPanel.addEventListener('dragleave', e=>{ assetsPanel.style.background=''; });
assetsPanel.addEventListener('drop', async e=>{
  e.preventDefault(); assetsPanel.style.background=''; const items = Array.from(e.dataTransfer.files || []);
  for(const f of items){
    if(f.type.startsWith('image/')){ const d = await readFileAsDataURL(f); if(activeMode==='objects') assets.objects.push(d); else assets.tiles.push(d); }
    else if(f.type==='application/json' || f.name.endsWith('.json')){ const txt = await f.text(); const parsed = safeParseJSON(txt); if(!parsed) continue; parsed.width = parsed.width || (Array.isArray(parsed.grid) && parsed.grid[0] ? parsed.grid[0].length : 1); parsed.height = parsed.height || (Array.isArray(parsed.grid) ? parsed.grid.length : 1); const preview = await makePreviewFromObjectJson(parsed).catch(()=>null); assets.objects.push({ type:'object', data: parsed, preview }); }
  }
  populateAssets();
});

// --- Save/export ---
exportBtn.addEventListener('click', ()=>{ const data = JSON.stringify(room,null,2); const blob = new Blob([data],{type:'application/json'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=(room.name||'room')+'.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); });

saveRoomBtn.addEventListener('click', async ()=>{ const data = JSON.stringify(room,null,2); if('showSaveFilePicker' in window){ try{ const handle = await window.showSaveFilePicker({ suggestedName:(room.name||'room')+'.json', types:[{ description:'JSON', accept:{ 'application/json': ['.json'] } }] }); const writable = await handle.createWritable(); await writable.write(data); await writable.close(); alert('Saved successfully'); } catch(err){ alert('Save cancelled or failed: '+err); } } else { const blob = new Blob([data],{type:'application/json'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=(room.name||'room')+'.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }});

// --- Clear helpers ---
clearBtn.addEventListener('click', ()=>{ room.background = createEmptyGrid(room.width, room.height); renderGrid(); });
clearObjectsBtn.addEventListener('click', ()=>{ room.objects = []; renderGrid(); });

// --- Init ---
room.background = createEmptyGrid(room.width, room.height);
tryLoadManifest();
renderGrid();

</script>
</body>
</html>
